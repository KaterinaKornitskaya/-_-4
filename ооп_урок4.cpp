// ооп_урок4.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include<iostream>
#include<time.h>
using namespace std;


class Test1
{
    int a;
    int b;
public:
    Test1(): a(0), b(0)  // список инифиализаторов 
    {                    // в поле а записывается 0, в поле b записывается 0
    
    }
    Test1(int x, int y) : a(x), b(y)  // значение х принимается из main
    {                                 // мы присваиваем значение х, которое было
                                      // принято из main, в поле a
    }
    // запись выше отличается последовательностью действий - мы создаем объект
    // и тут же при его создании записываем в этот объкт конкретное значение
    // аналогично тому, что мы напишем:
    // class Test
    // {
    //    int a = 0;...
    // 
    // другая ситуация - если все это мы пишем в теле конструктора, напр:
    // Test (int x, int y) // последовательность в этом случае:
    // {                   // сначала создается объекты класса (в class),
    // a = 0;              // выделяется на память на каждый из его полей, последовательно на а, потом на b
    // b = 0;              // и тут же записываются в него мусорные значения,
    // }                   // а потом происходит инициализация
    ~Test1() 
    {
        std::cout << "Destructor";
    }  
};

// когда необходима инициализация (смотрим на class Point после class Test)
class Test
{
    int temp;
    int temp2;
public:
    /*Test()  // конструктор по умолчанию - отсутствует
    {
        temp = 0;
    }*/
    Test(int t, int t2)  // конструктор с параметрами
    {
        temp = t;
        temp2 = t2;
    }
    void Show()
    {
        cout << temp << endl;
    }
    int Gettemp()
    {
        return temp;
    }
};

class Point
{
    const int x;  // полем класса является константа, необходмо инициализировать
                  // инициализтор в конструкторе ниже Point
    int y;
    int& z;       // ссылка также должна быть инициализирована
                  // инициализтор в конструкторе ниже Point 
    Test obj;     // объект другого класса  - чтобы такой объект создался
                  // тоже необходим список инициализации
public:
    Point(int x1, int y1, int z1, int t1, int t2) : x(x1), z(z1), obj(t1, t2) // инициализаторы, x1 и т.д. хотим передать из main
    {
        cout << "Construct with parameters\n";  // тело функции при наличии инициализаторов
                                         // может быть пустым, нужны только {}
       // x = x1; - так не дает написать, т.к. х это константа, только через список инициализаторов!
        y = y1;
    }

    void Output()
    {
        cout << "X: " << x << "\tY: " << y << endl;
    }
    int GetObjFirstField()
    {
        return obj.Gettemp();
    }
};

int main1()
{
    Point a(10, 1, 100, 1000, 8);
    Point b(20, 2, 200, 2000, 9);
    cout << b.GetObjFirstField() << endl;
    a.Output();

    return 0;
}

/* 
    Инициализация
    int a = 23;
    int b{ 23 }; - унифицированная инициализация  
    int c{ 3.23 };
    Особенность - унифицированная инициализация запрещает сужающее
    преобразование типов данных.
    Унифицированная - потому что таким образом мы можем инициализировать и 
    массивы, структуры, классы.

    int a = 23;     // в таком варианте все ок и 
    int b{ 23 };    // происходит сужающее преобразование данных
    int c = 3.23;   // 

    int a = 23;     // в этом варианте компилятор запрещает
    int b{ 23 };    // сужающее образование, и программа не 
    int c{ 3.23 };  // запустится

    Инициализация необходима:
    - когда полем класса является константа
    - когда полем класса является ссылка
    - когда полем класса является объект другого класса, у которого
      отсутствует конструктор по умолчанию
  */


class Static
{
    double d;
    
public:
    static int numberOfObject;  // сейчас публичный доступ, оно доступно
                                // именно поэтому мы из main свободно пользуемся ним
    Static()
    {
        d = 0;
        numberOfObject++;  // изначально инициализировали 0 (ниже после конца класса)
                           // каждый раз, когда мы создаем статическое поле, увеличиваем на 1
    }
    void Output()
    {
        cout << d << endl;
    }
    int Get()
    {
        return d;
    }
    void Set(int x)
    {
        d = x;
    }
    ~Static()
    {
        numberOfObject--;  // в каждом деструкторе уменьшаем кол-во объектов
    }

   //static int getNumber()
   //{
   //    return numberOfObject;
   //}
};

int Static::numberOfObject = 0;  // инициализация статического поля

void SomeFunc()
{
    static int count = 0;   // локальная статическая переменная
    count++;                // область видимости ограничена этой ф-ей, но время жизни сохраняется
    cout << count << endl;  // до конца программы 
}  // если бы вместо static int count = 0; было int count = 0; - время 
   //  жизни было бы только в этой ф-ии, а Не до конца программы


int main2()
{
    cout << Static::numberOfObject << endl;  // обращаемся к статическому полю до создания объекта
                                          // кол-во объектов = 0 - так как обращение к этому поля
                                          // происходит без обращения к имени объекта

    Static obj; // создали первый объект
    cout << Static::numberOfObject << endl;  // теперь кол-во объектов будет 1
                                             // потому что мы создали 1 объект к этому моменту, а поле
                                             // numberOfObject показывает кол-во существующих в данный
                                             // момент объектов
                                             // почему так произошло? мы в конструкторе Static(), который
                                             // в данный момент отработал, прописали этот инкремент (numberOfObject++)
    Static obj1;  // создали второй объект
    cout << Static::numberOfObject << endl;  // теперь увидели, что кол-во объектов = 2
    cout << obj1.numberOfObject << endl; // 2
    {  // создали третий объект, но {} говорят о том, что только в данной {} области видимости
        Static obj2;  // создали триетий объект
        cout << Static::numberOfObject << endl; // увидели, что кол-во объектов = 3
    }
    cout << Static::numberOfObject << endl;  // после выхода из предыдущей области видимости кол-во объектов опять = 2
                                             // третий объект после выходя из обл видимости уничтожился



    //cout << Static::getNumber();
    SomeFunc();  // это касается ф-ии void SomeFunc()
    SomeFunc();  // это касается ф-ии void SomeFunc()
    SomeFunc();  // это касается ф-ии void SomeFunc()

    return 0;
}


// если static int numberOfObject перенесем из паблик в приват:
class Static1
{
    double d;
    static int numberOfObject;  // перенесли из паблик в приват, и не сможеи пользоваться в main
    // тогда нам нужны статические методы класса
public:
   
    Static1()
    {
        d = 0;
        numberOfObject++;  // изначально инициализировали 0 (ниже после конца класса)
        // каждый раз, когда мы создаем статическое поле, увеличиваем на 1
    }
    void Output()
    {
        cout << d << endl;
    }
    int Get()
    {
        cout << this << endl;  // this известен внутри каждой ф-ии чтения класс
                               // и равен адресу того объекта, для которого эта
                               // ф-ия вызвана (адрес каждый раз разный)
        // решает проблему дублирования в памяти кода всех методов
        return d;
    }
    void Set(int x)
    {
        d = x;
    }
   // void Set(int d)  // если мы хотим, чтобы эта ф-ия принимала параметр d
   // {                // и хотим написать, что d=d
   //    // d = d;     // можно написать и так
   //    this->d = d;  // но лучше написать так, this это указаетль объкт, для которого
   //                  // ф-ия вызывается, а в каждом этом объекте есть поле d, то
   //                  // таким образом мы получаем доступ к нашему полю d
   //                  // полю d этого объкта мы присваиваем значение параметра d,
   //                  // которое мы передаем из main
   // }
    ~Static1()
    {
        numberOfObject--;  // в каждом деструкторе уменьшаем кол-во объектов
    }

    static int getNumber()  // статический метод - память на него тоже выделяется сразу, как создан класс
    {
        return numberOfObject;  // вернуть значение статического поля
    }
};

int main4()
{
    cout << Static1::getNumber() << endl;  // обращаемся к статическому полю до создания объекта
    // выведет 0
    
    Static1 obj; // создали первый объект
    // cout << obj.getNumber() << endl;  // теперь кол-во объектов будет 1
    cout << &obj << endl;  // смотрим чему равен адрес объекта obj
    // Указатель this:
    cout << obj.Get() << endl;
    // откуда геттер Get узнает, для какого объекта ф-ия Get() вызвана
    // (помимо того, что мы види глазами (obj.Get())?
    // на техническом уровне программе это понятно благодаря указателю this
    // всегда, когда вызывается какой-то метод, туда передается указатель this
    // он передается внутрь этой функции в виде невидимого пераметрами (у нас 
    // метод Get c пустым ()
    // на самом деле туда попадает этот параметр (this), который означает указатель
    // на тот объкт, для которого вызывается эта функция (указатель на объект obj)
  
    return 0;
}

/*   
    Экземплярные поля - это такие поля, которые дублируются в каждом объекте.
    Обычные методы тоже называют экземплярными.
    Методы - это функции-члены класса.
    Если нужно иметь поле, которое для всех объектов будет в единственном экземпляре - 
    тогда это не просто локальная переменная, которая находится в каждом объекте,
    а это общая переменная, которая относится ко всему классу.
    Время жизни статического поля равно времени жизни класса.
    Память для статических полей и методов выделяется при создании класса.
    Статические поля инициализируются сразу же при создании класса.

    Статические методы создают для работы со статическими полями.

    В статическом методе нельзя использовать нестатическое поле - память на
    статический метод выдкляется еще до создания объектов этого класса. Тоесть
    в памяти метод уже появился, а объекта еще нет.
    Мы не можем корректно
    создавать статический метод, память на который выделяется еще до создания
    хотя бы первого объекта, и использовать в нем какое-то обычное нестатическое
    поле, потому что память на конкретное поле еще не будет существовать.

    Идея стат.поле в том числе для экономии - мы выделяем одно поле для всех объктов.

    
    В обычном нестатическом методе использовать статическое поле можно.
    В нестатическом (обычном) методе выделяется память сразу на все нестатические
    методы во время создания первого объекта. А память на статическое поле 
    выделена еще раньше.
    
*/

/*
    Указатель this - это указатель на тот объект, для которого вызывается ф-ия.
    this - указатель, который содержит адрес того объекта, для которого эта ф-ия
    вызвана.
*/


// делегирование конструкторов:
class Test1
{
    int a;
    int b;
public:
  // Test1()        // стандартный вариант
  // {              // стандартный вариант
  //     a = 0;     // стандартный вариант
  //     b = 0;     // стандартный вариант
  // }              // стандартный вариант
    // или мы можем делегировать другому конструктору работу этого конструктора:
    Test1(): Test1(0,0)  // делегировали конструктор  Test1(int x, int y)
    {
                         // здесь оставляем пусто
    }
    Test1(int x) : Test1(x, 0)  // делегировали конструктор  Test1(int x, int y)
    {
                                // здесь оставляем пусто
    }
    Test1(int x, int y)
    {
        a = x;
        b = y;
    }
    void Output1()
    {
        cout << "a = " << a << "\tb" << b << endl;
    }
};

int main5()
{
    Test1 one(5);
    one.Output1(); 

    return 0;
}


// конструкторы копирования
class TestCopy
{
    int a;
    int b;
public:
    TestCopy()
    {
        cout << "Constructor!\n";
    }
    ~TestCopy()
    {
        cout << "Destructor!\n";
    }

};

// void Func(TestCopy someObj)  // внутри ф-ии создается копия 
// {                            // someObj - это копия нашего объекта one
//                              // передача объекта в ф-ия - побитовое копирование
//     cout << "In function!\n" << endl;
// }

TestCopy Func()
{
    TestCopy temp;
    cout << "In function!\n" << endl;
    return temp;  // в случает возврата значения из ф-ии с помощью return
                  // происходит тоже создание временной копии объекта temp
                  // и эта копию попадет в месте вызова  Func(); в main
    // *как происходит возврат из ф-ии с пом.return?
    // само возвращаемое значение записывается в место вызова.
    // какой механизм для этого? - создание временной копии
}

int main()
{
    
    TestCopy obj1;
    TestCopy obj2 = obj1;  // инициализация объекта obj2 объектом obj1
    // TestCopy obj2 { obj1 };  // или путем унифицированной инициализации, неважно
    // в случае когда полем класса является указатель на динамическую память,
    // объекты obj1 и obj2 будут содержать одинаковые указатели,
    // то есть смотреть на одну и ту же область динамич.памяти
    // и когда мы в деструкторе пропишем delete[], а память уже удалена,
    // удалить еще раз нельзя, будет ошибка на этапе выполнения
    // исправить это можно, прописав свой отдельный конструктор копирования
    // констр.копирования, как и обычный конструктор, не содеожит возвращаемого
    // значения
}


/*
    Конструктор копирования - 
    в случае выше отработает два конструктора - один до функции, а второй -
    конструктор копирования (внутри Func создался объект путем копирования)
    первым отработает деструктор копирования ддя функции
    а вторым деструктор для объекта one
*/
